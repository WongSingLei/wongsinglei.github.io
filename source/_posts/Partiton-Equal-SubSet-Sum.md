---
title: 分割等和子集
comment: true
date: 2020-04-19 14:53:23
updated: 2020-04-19 14:53:23
categories: 算法
tags:
---

[[LeetCode] Partition Equal Subset Sum 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

**题目描述**

给定一个**只包含正整数**的**非**空数组，判断该数组能否分成两个和相等的子数组。

每个数组中的元素不会超过 100；数组大小不会超过 200。

**样例输入**

输入[1,5,11,5]，返回true。可以分为 [1,5,5] 和 [11]

输入[1,2,3,5]，返回false。数组不能分割成两个元素和相等的子集。

**算法分析**

本题需要判断“数组能否分为两个和相等的子数组”等价于“在数组中选取一定数目的元素，能否使得选择的元素之和为sum/2（sum为数组所有元素的和）”等价问题是**经典的0-1背包问题**

**解法**

1、**暴力解法**

枚举原数组的所有子集，计算每个子集之和能否等于 sum/2，但是含有n个元素的数组的子集数组为 $$2^n$$ 个。当 n 比较大时，时间耗费巨大。

2、**动态规划**

假设数组存在子集 $[num_1, num_2, ..., num_k]$ 满足和为 sum/2，那么从该子集中减去最后一个元素 $num_k$ ,其和一定为 $sum/2 - num_k$ 。也就是说子问题为：是否存在一个子集，其和为 $sum/2 - num_k$ ？

该问题一定存在解（可用反证法证明）。这样，我们把一个规模比较大的问题归结成了规模比较小的子问题。

如何确定子问题是否有解。

假设 $dp[i][j]$ 表示数组中前 i 个元素能否得到和为 j 的子数组。（ $dp[i][j]=$1 表示能得到， $dp[i][j]=0$ 反之）那么对于第 i 个元素有两种情况，一种是第 i 个元素在和为 j 的子集中，那么对于前 i-1 个元素，可以得到和为 j-nums[i] 的子数组；另一种是第 i 个元素不在和为 j 的子集中，那么对于前 i-1 个元素，可以得到和为 j的子数组。即有以下关系：

$dp[i][j]=dp[i-1][j] | dp[i-1][j-nums[i]]$

**优化**

上述解法的时间复杂度和空间复杂度均为 $O(n * sum)$ ，我们发现：第 i 次迭代的过程只与第 i-1 个迭代有关，而与前 i-2 次迭代过程无关，因此我们首先可以考虑使用 $2 \times sum$ 的滚动数组来解决此题。此时把时间复杂度减少为 $O(sum)$。

**一维动态规划**

假设 $dp[j]$ 表示第 i 次迭代能否得到和为 j 的子数组，那么只要保证此时数组中存储的是上次（i-1 次）迭代的结果，我们就可以去掉一个维度。

因此我们有如下关系：

$dp[j] = dp[j] | dp[j-nums[i]]$

这种情况下，内层循环必须从大到小循环

因为如果我们从 nums[i] 遍历到 sum/2 的话，假如 nums[i]=1 的话，那么[1, sum/2]中所有的 dp 值都是true，因为 dp[0] 是 true，dp[1] 或上 dp[0] 为true，dp[2] 或上 dp[1] 为true，依此类推，完全使我们的 dp数组失效了。

**参考代码**

一维动态规划

```C++
bool canPartition(vector<int> &nums) {
    int n = nums.size();
    int sum = 0;
    //遍历数组，求得所有数字之和
    for(int i = 0; i < n; i++) 
        sum += nums[i];
    //如果sum是奇数，不能分为相等的两个子数组
    if(sum % 2 != 0) // (sum & 1) == 1
        return false;
    //假设当前数组符合题意，sum/=2得到其中一个子集的所有元素之和
    sum /= 2;
    //定义一个bool数组dp
    //数组中的每一个元素dp[i]表示数字i能否由数组nums中的元素求和得到
    bool *dp = new bool[sum + 1];
    for(int i = 1; i <= sum; i++)
        dp[i] = false;
    //当和为0时，必定有0相加得0，所以dp[0]为true
    dp[0] = true;

    //再次遍历数组nums
    for(int i = 0; i < n; i++) {
        //根据sum大小进行sum次迭代
        //j的值由nums中的元素相加得到
        //当j>=nums[i]时，j可能包含了nums[i]
        for(int j = sum; j >= nums[i]; j--)
            //如果 j 包含nums[i]
            //那么 j-num 是由 num 之外的另外若干元素相加得到的
            //dp[j] 的值与 dp[j - nums[i]] 相同
            //如果 j 不包含nums[i]，保持原有真值
            //只要 dp[j] 和 dp[j - nums[i]] 中有一个为真，说明dp[j]为真
            dp[j] = dp[j] | dp[j - nums[i]];
    }
    return dp[sum];
}
```

